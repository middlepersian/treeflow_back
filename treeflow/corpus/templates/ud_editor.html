{% extends "base.html" %}
{% block content %}
<div class="flex flex-row gap-2 mt-2">
  {% if prev %}
  <a href="{% url 'corpus:ud_editor' section_id=prev.id %}"
    class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">
    ← Prev
  </a>
  {% endif %}
  {% if next %}
  <a href="{% url 'corpus:ud_editor' section_id=next.id %}"
    class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">
    Next →
  </a>
  {% endif %}

  <button class="p-2 bg-blue-900 rounded text-white font-bold" id="enhanced">
    Hide Enhanced UD
  </button>
  <button class="flex p-2 bg-blue-900 rounded text-white font-bold" id="center">
    Center
  </button>
  <form class="mx-2" id="form" action="../saveNewDependency/" method="post">
    {% csrf_token %}
    <input type="hidden" name="dependency" value />
    <input type="hidden" name="section_id" value="{{section.id}}" />
    <select id="depType" name="depType" class="hidden" required>
      {% for d in deprel %}
      <option value="{{d}}">{{d}}</option>
      {%endfor%}
    </select>
    <input type="checkbox" name="enhanced" value="true" id="enhanced"
      class="hidden" />
  </form>
  <form class="mx-2" id="updateDep" action="../updateDependency" method="post">
    <select id="selectedDepType" name="depType" class="hidden">
      {% for d in deprel %}
      <option value="{{d}}">{{d}}</option>
      {%endfor%}
    </select>
  </form>
  <form class="mx-2" id="deleteDep" action="../deleteDependency/" method="post">
    {% csrf_token %}
    <input type="hidden" name="section_id" value="{{section.id}}" />
  </form>
</div>
<p id="depDetails"></p>
<svg id="svgCanvas" viewbox="0 0 800 600" width="100%" height="100%">
  <defs>
    <marker id="arrowhead" viewBox="0 0 60 60" refX="60" refY="30"
      markerUnits="strokeWidth" markerWidth="5"
      markerHeight="5" orient="auto">
      <path d="M 0 0 L 60 30 L 0 60 z" fill="#800000" />
    </marker>
    <marker id="arrowhead" markerWidth="4" markerHeight="5" refX="60" refY="3.5"
      orient="a">
      <polygon points="0 0, 10 3.5, 0 7" />
    </marker>
  </defs>
  {% for token in tokens %} {% if token.number != null %}
  <g class="p-2 rounded fill-slate-500 hover:fill-slate-900 cursor-pointer"
    id="{{token.id}}">
    <circle id="{{token.id}}" cx="{{token.xpos}}" cy="35"
      class="hover:fill-black hover:stroke-none" r="2.5"
      fill="white" stroke="black" />
    <text class="hover-target token" data-tokenId="{{token.id}}"
      x="{{token.xpos}}" y="50" font-family="Verdana"
      font-size="12">
      {% if token.transcription %}
      {{token.transcription}}
      {% else %}
      null
      {% endif %}
    </text>
    <text x="{{token.xpos}}" y="60" font-family="Verdana" font-size="6">
      {% for pos in token.pos %}
      <tspan>{{pos.pos}}</tspan>
      {% for feat in pos.features %}
      {% if feat.value != null %}
      <tspan x="{{token.xpos}}" dy="6">{{feat.name}}:</tspan>
      <tspan x="{{token.xpos}}" dy="6" dx="10">{{feat.value}}</tspan>
      <tspan x="{{token.xpos}}" dy="6" dx="15">|</tspan>
      <!-- Increase dx for spacing -->
      {% endif %}
      {% endfor %}
      {% endfor %}
    </text>

  </g>
  {% endif %} {% endfor %}
</svg>

{{ tokens | json_script:"tokenData"}} {{ deprel | json_script:"deprel" }}

<script>

// Variables to hold the current position and scale of the viewbox
const svgNS = "http://www.w3.org/2000/svg";
const svg = document.getElementById("svgCanvas");
const form = document.getElementById("form");
const pt = svg.createSVGPoint();
let focusDep = null;
let isPanning = false;
let startX = 0;
let startY = 0;
let creating = false;
let currentX = 0;
let currentY = 0;
let currentZoom = 1;
let fromTokenId = null;
let pathColor = "#264d73";
let enhancedPathColor = "#008060";
let enhancedEnabled = true;

function cursorPoint(evt) {
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  return pt.matrixTransform(svg.getScreenCTM().inverse());
}

const tokenData = JSON.parse(
  document.getElementById("tokenData").textContent
);


const deprelData = JSON.parse(document.getElementById("deprel").textContent);

function clearFocusDep() {
  // remove delete button
  const form = document.getElementById("deleteDep");
  while (form.querySelector('input[type="submit"]')) {
    form.removeChild(form[0]);
  }

  // remove the red stroke from the path
  const oldFocusPath = document.getElementById(focusDep);
  oldFocusPath.setAttribute("stroke", "none");

  focusDep = null;
  // clear all information about the dependency and the corresponding tokens in the p tag
  const depDetails = document.getElementById("depDetails");
  depDetails.innerHTML = ``;
}

function hideEnhancedPaths() {
  const groups = document.querySelectorAll("g[data-enhanced='true']");
  // check if the focusDep is an enhanced path and if so, do not hide it
  if (focusDep) {
    const focusPath = document.getElementById(focusDep);
    if (focusPath.getAttribute("data-enhanced") == "true") {
      clearFocusDep();
    }
  }
  groups.forEach((group) => {
    if (group.getAttribute("data-enhanced") == "true") {
      group.classList.add("hidden");
    }
  });
}

function showEnhancedPaths() {
  const groups = document.querySelectorAll("g[data-enhanced='true']");
  groups.forEach((group) => {
    group.classList.remove("hidden");
  });
}

document.addEventListener("DOMContentLoaded", (event) => {

  const bbox = svg.getBBox();
  setViewBox(bbox.x, bbox.y, bbox.width, bbox.height);
  // add event listener to the enhanced button
  document.getElementById("enhanced").addEventListener("click", (event) => {
    if (enhancedEnabled) {
      enhancedEnabled = false;
      event.target.innerHTML = "Show Enhanced UD";
      hideEnhancedPaths();
    } else {
      enhancedEnabled = true;
      event.target.innerHTML = "Hide Enhanced UD";
      showEnhancedPaths();
    }
    console.log(enhancedEnabled);
  });
});

//#region CLICK HANDLE
document.querySelectorAll("circle").forEach((item) =>
  item.addEventListener("click", (event) => {
    if (!creating) {
      creating = true;
      fromTokenId = event.target.id;
      hideFocusDep();
      return;
    }
    if (creating) {
      const tokenTo = event.target.id;
      if (tokenTo) {
        const path = document.createElementNS(svgNS, "path");
        const arcDefinition = createBezierArc(
          tokenData.find((e) => e.id === fromTokenId).xpos,
          32.5,
          tokenData.find((e) => e.id === tokenTo).xpos,
          32.5
        );

        path.setAttribute("d", arcDefinition);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "black");
        path.setAttribute("stroke-width", "1.5");
        path.setAttribute("marker-end", "url(#arrowhead)");
        path.setAttribute("data-from", fromTokenId);
        path.setAttribute("data-to", tokenTo.id);
        path.addEventListener("click", (event) => {
          focusDep = event.target.id;
          const focusPath = document.getElementById(focusDep);
          focusPath.removeAttribute("stroke");
          focusPath.setAttribute("stroke", "red");
          console.log("Path clicked");
        });
        svg.appendChild(path);
        addNewDependencyRow(fromTokenId, tokenTo);
        creating = false;
        fromTokenId = null;
        cleanAllElementsWithClass("temp-path");
      }
    }
  })
);
//#endregion

//#region create temp path
svg.addEventListener("mousemove", (event) => {
  if (!creating) {
    return;
  }
  var loc = cursorPoint(event);
  const mouseX = loc.x;
  const mouseY = loc.y - 5;
  cleanAllElementsWithClass("temp-path");
  const path = document.createElementNS(svgNS, "path");
  const arcDefinition = createBezierArc(
    tokenData.find((e) => e.id === fromTokenId).xpos,
    35,
    mouseX,
    mouseY
  );
  path.setAttribute("d", arcDefinition);
  path.setAttribute("fill", "none");
  path.setAttribute("stroke", "black");
  path.setAttribute("stroke-width", "1");
  path.setAttribute("marker-end", "url(#arrowhead)");
  path.classList.add("temp-path");
  svg.appendChild(path);
});
//#endregion

function createBezierArc(x1, y1, x2, y2, upwards = true) {
  const cp1x = x1;
  const cp2x = x2;
  const arcHeight = Math.abs(x1 - x2)*0.4;
  const cp1y = y1 - (upwards ? arcHeight : -arcHeight);
  const cp2y = y2 - (upwards ? arcHeight : -arcHeight);
  return `M ${x1},${y1} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${x2},${y2}`;
}

function cleanAllElementsWithClass(className) {
  const tempPaths = document.getElementsByClassName(className);
  while (tempPaths.length > 0) {
    tempPaths[0].parentNode.removeChild(tempPaths[0]);
  }
}

tokenData.forEach((token) => {
  token.dependencies?.forEach((dep) => {
    if (!dep.to_token_id) {
      return;
    }
    if (dep.enhanced) {
      if (!enhancedEnabled) {
        return;
      }
      pathColor = enhancedPathColor;
    }
    const depPos = tokenData.find((e) => e.id === dep.to_token_id.id).xpos;
    const g = document.createElementNS(svgNS,"g");
    g.setAttribute("data-enhanced",dep.enhanced)
    g.setAttribute("data-id",dep.id)
    const path = document.createElementNS(svgNS, "path");
    const arcDefinition = createBezierArc(token.xpos, 32.5, depPos, 32.5);
    path.setAttribute("d", arcDefinition);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", pathColor);
    path.setAttribute("stroke-width", "1.5");
    path.setAttribute("class", "hover:stroke-red-500 cursor-pointer");
    path.setAttribute("marker-end", "url(#arrowhead)");
    path.setAttribute("data-from", token.id);
    path.setAttribute("data-to", dep.to_token_id.id);
    path.setAttribute("data-enhanced", dep.enhanced);
    path.setAttribute("id", dep.id);
    const text = document.createElementNS(svgNS, "text");
    text.setAttribute("font-size", 8);
    const textpath = document.createElementNS(svgNS, "textPath");
    textpath.setAttribute("path", arcDefinition);
    if(token.xpos > depPos){
      textpath.setAttribute("startOffset", "55%");
      textpath.setAttribute("side", "right");

    }
    textpath.setAttribute("startOffset", "45%");
    textpath.innerHTML = dep.rel;
    text.append(textpath);
    path.addEventListener("click", (event) => {
      hideFocusDep();
      focusDep = event.target.id;
      const focusPath = document.getElementById(focusDep);
      focusPath.removeAttribute("stroke");
      focusPath.setAttribute("stroke", "red");
      const form = document.getElementById("deleteDep");
      const inputDep = document.createElement("input");
      inputDep.setAttribute("type", "hidden");
      inputDep.setAttribute("name", "dep_id");
      inputDep.setAttribute("value", focusDep);
      form.appendChild(inputDep);

      // only add the submit button if it is not already there
      const submit = document.createElement("input");
      submit.setAttribute("type", "submit");
      submit.setAttribute("value", "Delete");
      submit.setAttribute(
        "class",
        "flex mx-2 p-2 bg-red-500 rounded text-white font-bold hover:bg-blue-700 cursor-pointer"
      );
      if (!form.querySelector('input[type="submit"]')) {
        form.appendChild(submit);
      }
      // display all information about the dependency and the corresponding tokens in the p tag
      const depDetails = document.getElementById("depDetails");
      depDetails.innerHTML = `From: ${token.transcription ? token.transcription : null}<br>To: ${tokenData.find((e) => e.id === dep.to_token_id.id).transcription
        }<br>Relation: ${dep.rel}`;

      console.log("Path clicked");
    });
    g.appendChild(path);
    g.appendChild(text);
    svg.appendChild(g)
    pathColor = "#264d73";
  });
});

function setViewBox(x, y, width, height) {
  svg.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
}

// Function to handle mouse movement
function onMouseMove(event) {
  if (isPanning) {
    // Calculate the new coordinates, adjusted for the zoom level
    const dx = (event.clientX - startX) / currentZoom;
    const dy = (event.clientY - startY) / currentZoom;

    // Subtract the distances from the current viewbox position
    currentX -= dx;
    currentY -= dy;

    // Update the viewbox with the new position
    setViewBox(currentX, currentY, svg.clientWidth / currentZoom, svg.clientHeight / currentZoom);

    // Update the starting X and Y positions for the next movement
    startX = event.clientX;
    startY = event.clientY;
  }
}

// Function to handle the end of mouse movement
function onMouseUp() {
  // Unset the panning flag
  isPanning = false;

  // Remove the event listeners
  document.removeEventListener("mousemove", onMouseMove);
  document.removeEventListener("mouseup", onMouseUp);
}

// The mousedown event to initiate panning
svg.onmousedown = function (event) {
  // Prevent default behavior (like selecting text)
  event.preventDefault();

  // Set the panning flag
  isPanning = true;

  // Store the starting X and Y positions
  startX = event.clientX;
  startY = event.clientY;

  // Add the event listeners for mousemove and mouseup
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
};


svg.onwheel = function (event) {
  event.preventDefault();

  // Zoom intensity determines the rate of zooming
  const zoomIntensity = 0.1;

  // Determine the direction of the scroll (up for zoom in, down for zoom out)
  const wheelDelta = event.deltaY < 0 ? 1 : -1;

  // Calculate the zoom factor
  const zoom = Math.exp(wheelDelta * zoomIntensity);

  // Calculate the center of the current viewbox
  const viewboxCenterX = currentX + (svg.clientWidth / currentZoom) / 2;
  const viewboxCenterY = currentY + (svg.clientHeight / currentZoom) / 2;

  // Adjust the currentX and currentY to zoom towards the center of the current viewbox
  currentX -= (viewboxCenterX - currentX) * (zoom - 1);
  currentY -= (viewboxCenterY - currentY) * (zoom - 1);

  // Update the zoom level
  currentZoom *= zoom;

  // Update the SVG viewbox to reflect the new zoom level and position
  setViewBox(currentX, currentY, svg.clientWidth / currentZoom, svg.clientHeight / currentZoom);
};

document.getElementById('center').onclick = function () {
  // Get the initial bounding box of the SVG content
  const bbox = svg.getBBox();

  // Set the current X and Y to the top-left corner of the bounding box
  // Adjust these values as needed to align with your specific layout
  currentX = bbox.x;
  currentY = bbox.y;

  // Reset the zoom level to its initial state, typically 1
  currentZoom = 1;

  // Update the SVG viewbox to center the content
  // The width and height should be set according to your initial viewbox or the SVG's bounding box
  setViewBox(currentX, currentY, bbox.width, bbox.height);
};

function calculateZoomLevel() {
    const svgContainer = document.getElementById("svgContainer");

    const elements = svg.getElementsByTagName("*");
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      const bbox = element.getBBox();
      minX = Math.min(minX, bbox.x);
      minY = Math.min(minY, bbox.y);
      maxX = Math.max(maxX, bbox.x + bbox.width);
      maxY = Math.max(maxY, bbox.y + bbox.height);
    }

    const viewBoxWidth = maxX - minX;
    const viewBoxHeight = maxY - minY;

    const containerWidth = svgContainer.clientWidth;
    const containerHeight = svgContainer.clientHeight;

    const zoomX = containerWidth / viewBoxWidth;
    const zoomY = containerHeight / viewBoxHeight;

    const zoomLevel = Math.min(zoomX, zoomY);

    return zoomLevel;
  }


  const addNewDependencyRow = (from, to) => {
    const inputContainer = document.createElement("div");
    inputContainer.setAttribute("class", "flex flex-row items-center");

    const inputField = document.createElement("input");
    inputField.setAttribute("type", "hidden");
    inputField.setAttribute("name", "from");
    inputField.setAttribute("value", from);
    inputContainer.appendChild(inputField);

    const inputField1 = document.createElement("input");
    inputField1.setAttribute("type", "hidden");
    inputField1.setAttribute("name", "to");
    inputField1.setAttribute("value", to);
    inputContainer.appendChild(inputField1);

    // show depType Selection
    const depType = document.getElementById("depType");
    depType.classList.remove("hidden");
    depType.classList.add("block");

    const enhancedInput = document.createElement("input");
    enhancedInput.setAttribute("type", "checkbox");
    enhancedInput.setAttribute("name", "enhanced");
    enhancedInput.setAttribute("value", "false");
    enhancedInput.setAttribute("id", "enhanced_input");

    const enhancedLabel = document.createElement("label");
    enhancedLabel.setAttribute("for", "enhanced_input");
    enhancedLabel.innerHTML = "enhanced";

    inputContainer.appendChild(enhancedInput);
    inputContainer.appendChild(enhancedLabel);
    const submit = form.querySelector('input[type="submit"]');
    if (!submit) {
      const submitButton = document.createElement("input");
      submitButton.setAttribute("type", "submit");
      submitButton.setAttribute("value", "Save Changes");
      submitButton.setAttribute(
        "class",
        "flex mx-2 p-2 bg-blue-900 rounded text-white font-bold hover:bg-blue-700 cursor-pointer"
      );
      inputContainer.appendChild(submitButton);
    }

    form.appendChild(inputContainer);
  };

  function hideFocusDep() {
    if (focusDep) {
      const oldFocusPath = document.getElementById(focusDep);
      oldFocusPath.removeAttribute("stroke");
      oldFocusPath.setAttribute("stroke", "black");

      // display all information about the dependency and the corresponding tokens in the p tag
      const depDetails = document.getElementById("depDetails");
      depDetails.innerHTML = ``;

      const form = document.getElementById("deleteDep");
      while (form.querySelector('input[type="submit"]')) {
        form.removeChild(form[0]);
      }
    }
  }

  function createArcPath(from, to) { }

  function hoverCard(event) {
    // only one hover card at a time
    const oldHoverCard = document.getElementById("hover-card");
    if (oldHoverCard) {
      document.body.removeChild(oldHoverCard);
    }

    console.log("hovering");
    //get the x and y coordinates of the mouse
    const x = event.clientX;
    const y = event.clientY;
    //get the element that is hovered
    const hoveredElement = document.elementFromPoint(x, y);
    // create the hover card
    const hoverCard = document.createElement("div");
    hoverCard.setAttribute("class", "hover-card");
    hoverCard.setAttribute("id", "hover-card");

    // get the token data
    const token = tokenData.find((e) => e.id === hoveredElement.getAttribute("data-tokenid"));
    const tokenInfo = document.createElement("p");
    // map the pos tags to a string
    const pos = token.pos.map((e) => {
      // map the features to a string
      const features = e.features.map((f) => {
        if (f.value) {
          return `${f.name}: ${f.value}`
        }
        return `${f.name}`
      }).join(", ");
      // return the pos tag with the features
      if (features) {
        return `${e.pos} (${features})`
      }
      return `${e.pos}`
    }
    ).join(", ");

    tokenInfo.innerHTML = `${token.transcription}
    <br>
    ${pos}
    `;

    // add the token info to the hover card

    hoverCard.appendChild(tokenInfo);


    // append the hover card to the body
    document.body.appendChild(hoverCard);
    // set the position of the hover card
    hoverCard.style.top = `${y}px`;
    hoverCard.style.left = `${x}px`;
    hoverCard.style.backgroundColor = "white";
    hoverCard.style.border = "1px solid black";
    hoverCard.style.position = "absolute";
    // min width and height
    hoverCard.style.minWidth = "100px";
    hoverCard.style.minHeight = "50px";

    // get the bounding box of the hover card
    const hoverCardBBox = hoverCard.getBoundingClientRect();
    // get the bounding box of the svg
    const svgBBox = svg.getBoundingClientRect();
    // check if the hover card is outside of the svg
    if (hoverCardBBox.right > svgBBox.right) {
      hoverCard.style.left = `${x - (hoverCardBBox.right - svgBBox.right)}px`;
    }
    if (hoverCardBBox.bottom > svgBBox.bottom) {
      hoverCard.style.top = `${y - (hoverCardBBox.bottom - svgBBox.bottom)}px`;
    }

  }

  function removeHoverCard() {
    setTimeout(() => {
      const hoverCard = document.getElementById("hover-card");
      if (hoverCard) {
        document.body.removeChild(hoverCard);
      }
    }, 100); // Delay of 1 second (1000 milliseconds)
  }

  // add event listeners to all text elements with the class token

  document.querySelectorAll(".token").forEach((item) => {
    item.addEventListener("mouseenter", (event) => {
      hoverCard(event);
    });
    item.addEventListener("mouseleave", (event) => {
      removeHoverCard();
    });
  });
  // Initialize the viewbox
  const bbox = svg.getBBox();
  currentX = bbox.x - 10;
  currentY = bbox.y - 10;
  currentZoom = 1;
  setViewBox();
</script>
{% endblock content %}