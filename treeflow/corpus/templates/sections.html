{% extends "base.html" %}
{% load static tailwind_tags i18n %}

{% block content %}

<!-- Content block starts here -->
<div class="flex flex-col w-full">

    <!-- Main content and sidebar container -->
    <div class="grid grid-cols-8 flex-grow">

        <!-- Sidebar -->
        <div
            class="sticky top-[4rem] h-[calc(100vh-4rem)] overflow-y-auto col-span-1 bg-gray-100 p-4 z-10">

            <!-- Text Dropdown -->
            <div class="flex-none max-w-xs">{% include 'text_dropdown.html' with text_id=selected_text_id %}</div>

            <!-- Edit Button (Conditionally Rendered for Authenticated Users) -->
            {% if request.user.is_authenticated %}
            <button id="startTokenSelection"
                class="px-4 py-2 mt-4 font-bold text-white rounded bg-main hover:bg-main-dark"
                data-mode="select">
                {% trans 'Start Token Selection' %}
            </button>
            {% endif %}
            <!-- Sidebar Content Including Edit Button -->
            <div class="z-10 px-4 py-2 bg-gray-200 shadow-md">
                <h2 class="mb-4 text-lg font-bold">{% trans 'Select Section Type' %}</h2>
                <!-- Dropdown Menu for selecting section type -->
                <select id="sectionTypeSelector" class="mb-4">
                    {% for section_type in section_types %}
                    <option value="{{ section_type }}">{{ section_type|title }}</option>
                    {% endfor %}
                </select>
                <!-- Section List Placeholder -->
                <div id="sectionList">
                    <!-- Sections will be dynamically loaded here -->
                </div>

            </div>

        </div>

        <!-- Content Area for sentences -->
        <div class="col-span-3 overflow-y-auto relative">
            <!-- Loop over sections of type 'sentence' -->
            {% for section in sentence_sections %}
            <!-- Sentence Block starts -->
            <div
                class="flex items-center p-2 mb-2 bg-white rounded shadow sentence">
                <!-- Display sentence section title or identifier with a fixed width -->
                <div id="{{ section.id }}" class="mr-1 font-bold sentence-identifier w-1/8">
                    <a href="{% url 'corpus:ud_editor' section.id %}"
                    class="text-main hover:text-main-dark">
                    {{ section.number|default:"Untitled" }} 
                  </a>
                </div>


                <!-- Sentence content tokens displayed next to the identifier -->
                <div class="flex flex-wrap sentence-content w-2/8">
                        {% for token in section.prefetched_tokens %}
                            <span class="token inline-block rounded px-1 py-0.5 m-0.5"
                                data-token-id="{{ token.id }}"
                                data-section-id="{{ section.id }}">
                                {{ token.transcription }}
                            </span>
                        {% endfor %}
                </div>

                {% if request.user.is_authenticated %}
                <div class="mr-1 font-bold sentence-identifier w-1/8">
                    <a href="{% url 'corpus:sentence' section.id %}"
                    class="text-xl font-bold text-off hover:text-action"> 
                    &#x270F; <!-- Unicode pencil icon -->
                    </a>
                </div>
                {% endif %}
                
            </div>
            {% empty %}
            <p>{% trans 'No sentence sections found for this text.' %}</p>
            {% endfor %}

             <!--
            <div class="fixed bottom-4 right-4 z-50">
                <button id="scrollToTopButton" class="scroll-to-top px-4 py-2 text-white font-bold rounded bg-main hover:bg-main-dark">â†‘</button>
            </div> -->
        
            
            
        </div>
        
        <!-- Right Column for Image -->

        <div class="col-span-4 sticky top-0 h-screen">
            <div id="iiif-viewer" class="h-full w-full">  {% include 'components/OpenSeaDragon.html' with sources=manuscripts %}</div>
        </div>
         
    </div>



    <input type="hidden" id="id_selected_tokens" name="selected_tokens" value>

    <div id="modalContainer"></div>


    <!-- Tooltip -->
    <div id="sectionInfoTooltip" class="hidden absolute z-50 px-4 py-2 bg-white rounded-md shadow-lg max-w-xs">
        <!-- Content will be dynamically inserted -->
    </div>


</div>

<script>
    var textId = '{{ selected_text_id }}';
    console.log("Selected text ID:", textId);
</script>


<!-- section navigator -->

<script>

// Highlight tokens when a section is clicked
document.addEventListener('DOMContentLoaded', function () {
    const selector = document.getElementById('sectionTypeSelector');
    const sectionList = document.getElementById('sectionList');

    function editSection(sectionId) {
    console.log('Edit section:', sectionId);
    let queryString = `?section_id=${encodeURIComponent(sectionId)}`;
    htmx.ajax('GET', '/corpus/load_section_modal/' + queryString, {
        target: '#modalContainer'
    }).then(() => {
        document.getElementById('modalTextId').value = sectionId;
        console.log('Section ID: ' + sectionId);
        console.log('Edit modal content loaded');
    });
    }
    // New function to add icons after sections are loaded
    function addIconsToSections() {
        const sections = document.querySelectorAll('.section-item');
        sections.forEach(section => {
            // Skip if icon already added
            if (section.querySelector('.edit-icon')) return;

            // Create edit icon
            const editIcon = document.createElement('span');
            editIcon.classList.add('edit-icon');
            editIcon.innerHTML = '&#9998;'; // Unicode for pencil icon
            editIcon.style.cursor = 'pointer';
            editIcon.style.marginLeft = '10px';

            // Edit icon click event
            editIcon.addEventListener('click', function(event) {
                event.stopPropagation();
                // Call function to handle edit action
                editSection(section.dataset.sectionId);
            });

            section.appendChild(editIcon);
        });
    }


    function openSectionFormular(sectionId) {
        // Logic to open section form with the given sectionId
        console.log('Open formular for section:', sectionId);
    }

    function checkUserLoggedIn() {
        // Implement logic to check if user is logged in
        return true; // Assuming user is logged in for this example
    }

    if (checkUserLoggedIn()) {
        addIconsToSections();
    }

    function fetchSectionDetails(sectionId) {
    return fetch(`/api/sections/${sectionId}/`)
        .then(response => response.json());
    }

    function showSectionInfo(event) {
        const sectionId = event.target.dataset.sectionId;
        fetchSectionDetails(sectionId)
            .then(data => {
                const relatedSectionPromises = data.related_to.map(relatedId => fetchSectionDetails(relatedId));

                Promise.all(relatedSectionPromises).then(relatedSections => {
                    const relatedIdentifiers = relatedSections.map(section => section.identifier).join(', ') || 'None';
                    const tooltip = document.getElementById('sectionInfoTooltip');

                    tooltip.innerHTML = `Type: ${data.type}, related to: ${relatedIdentifiers}`;
                    tooltip.style.left = `${event.pageX + 10}px`;
                    tooltip.style.top = `${event.pageY + 10}px`;
                    tooltip.classList.remove('hidden');
                });
            })
            .catch(error => console.error('Error fetching section info:', error));
    }
    function hideSectionTooltip() {
        const tooltip = document.getElementById('sectionInfoTooltip');
        tooltip.classList.add('hidden');
    }

    if (sectionList) {
        sectionList.addEventListener('mouseover', function (event) {
            if (event.target.classList.contains('section-item')) {
                showSectionInfo(event);
            }
        });

        sectionList.addEventListener('mouseout', function (event) {
            if (event.target.classList.contains('section-item')) {
                hideSectionTooltip();
            }
        });
    }

    function highlightSectionTokens(tokenIds) {
        const stringTokenIds = tokenIds.map(id => id.toString());
        const tokens = document.querySelectorAll('.token');
        tokens.forEach(token => {
            if (stringTokenIds.includes(token.dataset.tokenId)) {
                // Apply Tailwind class for highlighted tokens
                token.classList.add('bg-yellow-300'); // Tailwind class for yellow background
            } else {
                // Remove Tailwind class for non-highlighted tokens
                token.classList.remove('bg-yellow-300');
            }
        });
    }

    function fetchAndHighlightSectionTokens(sectionId) {
        fetch(`/corpus/get-tokens-for-section/${sectionId}/`)
            .then(response => response.json())
            .then(data => {
                const tokenIds = data.tokens; // Assuming the backend sends an array of token IDs
                highlightSectionTokens(tokenIds);

                // Scroll to the first token of this section
                if (tokenIds.length > 0) {
                    const firstTokenId = tokenIds[0];
                    const firstTokenElement = document.querySelector(`.token[data-token-id="${firstTokenId}"]`);
                    if (firstTokenElement) {
                        firstTokenElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching tokens for section:', error);
            });
    }
        function loadChildSections(sectionId, parentDiv) {
        // Check if child sections are already loaded
        const existingChildList = parentDiv.querySelector('.child-section-list');
        if (existingChildList) {
            // Remove the child list to 'close' the section
            parentDiv.removeChild(existingChildList);
            return; // Exit the function
        }
        fetch(`/corpus/get-child-sections/${sectionId}/`)
            .then(response => response.json())
            .then(childSections => {
                const childSectionList = document.createElement('div');
                childSectionList.classList.add('child-section-list');

                childSections.forEach(childSection => {
                    const childDiv = document.createElement('div');
                    childDiv.classList.add('child-section-item');
                    childDiv.textContent = childSection.identifier || 'Untitled';
                    childDiv.dataset.sectionId = childSection.id;

                    // Add edit icon to child sections
                    const editIcon = document.createElement('span');
                    editIcon.classList.add('edit-icon');
                    editIcon.innerHTML = '&#9998;'; // Unicode for pencil icon
                    editIcon.style.cursor = 'pointer';
                    editIcon.style.marginLeft = '10px';

                    // Edit icon click event
                    editIcon.addEventListener('click', function(event) {
                        event.stopPropagation();
                        // Call function to handle edit action
                        editSection(childDiv.dataset.sectionId);
                    });

                    childDiv.appendChild(editIcon);

                    // Add event listener to prevent event bubbling
                    childDiv.addEventListener('click', function (event) {
                        event.stopPropagation();
                        fetchAndHighlightSectionTokens(childSection.id);
                    });

                    childSectionList.appendChild(childDiv);
                });

                // Check if child sections are already loaded to avoid duplication
                if (!parentDiv.querySelector('.child-section-list')) {
                    parentDiv.appendChild(childSectionList);
                }
            })
            .catch(error => {
                console.error('Error fetching child sections:', error);
            });
    }

    // Modify existing functions to call addIconsToSections after sections are loaded
    function loadSectionsOfType(sectionType) {
        fetch(`/corpus/get-sections/${textId}/${sectionType}/`)
            .then(response => response.json())
            .then(sections => {
                sectionList.innerHTML = '';
                sections.forEach(section => {
                    const sectionDiv = document.createElement('div');
                    sectionDiv.classList.add('section-item');
                    sectionDiv.textContent = section.identifier || 'Untitled';
                    sectionDiv.dataset.sectionId = section.id;

                    sectionDiv.addEventListener('click', function () {
                        const isClosingSection = this.querySelector('.child-section-list');
                        loadChildSections(section.id, this);
                        if (!isClosingSection) {
                            fetchAndHighlightSectionTokens(section.id);
                        }
                    });

                    sectionList.appendChild(sectionDiv);
                });

                if (sections.length === 0) {
                    sectionList.innerHTML = '<p>No sections found for this type.</p>';
                } else {
                    addIconsToSections();
                }
            })
            .catch(error => {
                console.error('Error fetching sections:', error);
                sectionList.innerHTML = '<p>Error loading sections.</p>';
            });
    }

    selector.addEventListener('change', function () {
        loadSectionsOfType(this.value);
    });

    if (selector.options.length > 0) {
        loadSectionsOfType(selector.options[0].value);
    }
});
</script>

<!-- section creator -->
<script>
document.addEventListener('DOMContentLoaded', function () {
    let startTokenId = null;
    let endTokenId = null;
    let isSelectingTokens = false;
    let selectedTokens = []; // Array to hold selected tokens
    let selectedTokenIds = []; // Array to hold selected token IDs
    let selectedTokenTexts = ''; // String to hold selected token texts


    var csrfTokenMeta = document.querySelector('meta[name="csrf-token"]');
    if (csrfTokenMeta) {
        var csrfToken = csrfTokenMeta.getAttribute('content');
        console.log("CSRF token:", csrfToken);
        try {
            if (htmx && csrfToken) {
                htmx.config.include = (name, value, el) => {
                    if (name === "csrfmiddlewaretoken") {
                        return csrfToken;
                    }
                    return value;
                };
            } else {
                console.error("HTMX or CSRF token not available");
            }
        } catch (e) {
            console.error("Error configuring HTMX:", e);
        }
    } else {
        console.error("CSRF token meta tag not found");
    }

    // Declare the observer at the beginning
    const observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
            if (mutation.addedNodes && mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach(function (node) {
                    if (node.classList && node.classList.contains('token')) {
                        addTokenClickListeners();
                    }
                });
            }
        });
    });

    // Observer to observe the addition of new tokens
    function handleTokenClick(tokenElement) {
        console.log("Token clicked:", tokenElement.dataset.tokenId);
        const tokenId = tokenElement.dataset.tokenId;

        // When the first token is clicked, highlight it immediately
        if (startTokenId === null) {
            startTokenId = tokenId;
            tokenElement.classList.add('bg-green-200'); // Highlight the first token using Tailwind class
        }
        // When the second token is clicked, highlight the range
        else if (endTokenId === null && tokenId !== startTokenId) {
            endTokenId = tokenId;
            highlightTokensBetween(startTokenId, endTokenId); // Highlight tokens between the range using Tailwind class
        }
    }


    function highlightTokensBetween(startId, endId) {
        let inRange = false;
        document.querySelectorAll('.token').forEach(token => {
            if (token.dataset.tokenId === startId || token.dataset.tokenId === endId) {
                inRange = !inRange;
                token.classList.add('bg-green-200');
            }
            if (inRange || token.dataset.tokenId === endId) {
                token.classList.add('bg-green-200');
            }
        });
    }


    // Function to add event listeners to tokens
    function addTokenClickListeners() {
        document.querySelectorAll('.token').forEach(token => {
            token.addEventListener('click', function () {
                if (isSelectingTokens) {
                    handleTokenClick(this);
                }
            });
        });
    }

    // Add listeners to existing tokens
    addTokenClickListeners();
    document.getElementById('startTokenSelection').addEventListener('click', function () {
        let mode = this.getAttribute('data-mode');

        // Log the value of textId
        console.log("Current textId:", textId);

        if (mode === 'select') {
            // Start selecting tokens logic
            isSelectingTokens = true;
            this.textContent = 'Finish Token Selection';
            this.setAttribute('data-mode', 'finish');
        } else if (mode === 'finish') {
            // Finish selecting tokens logic
            isSelectingTokens = false;
            selectedTokens = Array.from(document.querySelectorAll('.token'))
                .filter(token => token.classList.contains('bg-green-200'));
            selectedTokenIds = selectedTokens.map(token => token.dataset.tokenId);
            selectedTokenTexts = selectedTokens.map(token => token.textContent).join(', ');
    
            let queryString = `?tokens=${encodeURIComponent(selectedTokenIds.join(','))}&text_id=${encodeURIComponent(textId)}`;
            console.log("Query string:", queryString);
            // Issue a GET request with the constructed query string
            htmx.ajax('GET', '/corpus/load_section_modal/' + queryString, {
                target: '#modalContainer'
            }).then(() => {
                // After the modal content is loaded, set the value of the hidden input
                document.getElementById('modalTextId').value = textId;
                console.log('text ID: ' + textId);
                console.log('Modal content loaded');
            });
        
            // Reset the button for a new selection
            this.textContent = 'Start Token Selection';
            this.setAttribute('data-mode', 'select');
        }

    });

    // Function to show the modal
    function openModal() {
        // Ensure the modal exists in the DOM
        let modal = document.getElementById('sectionModal');
        console.log('Opening modal');
        if (modal) {
            modal.classList.remove('hidden'); // Remove the 'hidden' class to show the modal            
            // Display the selected tokens
            document.getElementById('selectedTokensDisplay').textContent = selectedTokenTexts || 'No tokens selected';
        } else {
            console.error('Modal not found in the DOM.');
        }
    }


    function deselectAllTokens() {
        document.querySelectorAll('.token').forEach(token => {
            token.classList.remove('bg-green-200'); // Reset the token using Tailwind class
        });
        startTokenId = null; // Reset start token ID
        endTokenId = null;   // Reset end token ID
        selectedTokenIds = []; // Reset selected token IDs
    }


    function closeModal() {
        console.log('Closing modal');
        var modal = document.getElementById('sectionModal');
        if (modal) {
            modal.classList.add('hidden'); // Add the 'hidden' class to hide the modal            
            deselectAllTokens(); // Deselect tokens when closing the modal
            isSelectingTokens = false; // Reset the token selection flag
            selectedTokenTexts = ''; // Reset the selected token texts
        }
    }
    

    document.body.addEventListener('htmx:afterSwap', function (event) {
        console.log('htmx:afterSwap event triggered', event);
    
        // Log details about the event target
        console.log('Event target:', event.target);
        console.log('Event target ID:', event.target.id);
    
        if (event.target.id === 'modalContainer') {
            console.log('Preparing to open modal based on htmx:afterSwap in #modalContainer');
    
            // Attempt to open the modal
            openModal();
    
            // Try to find and bind the closeModal function to the Cancel button
            const cancelButton = document.querySelector('#sectionModal button[onclick="closeModal()"]');
            if (cancelButton) {
                console.log('Cancel button found in the modal, binding closeModal function');
                cancelButton.onclick = closeModal;
            } else {
                console.error('Cancel button not found in the modal.');
            }
        }
    });
    
    // Start observing
    observer.observe(document.body, { childList: true, subtree: true });
  
});
</script>


{% endblock content %}